\chapter{Implementierung} \label{chapter:implementation}

In diesem Kapitel wurde die Implementierung des Backends, Frontends und
Dashboards des Systems beschrieben. Die Implementierung basiert auf der in
\autoref{chapter:conception} erarbeiteten Konzeption.  Zunächst wurde das
Backend umgesetzt, welches sämtliche Daten des Systems speichert und die
Speicherung und Manipulation dieser durch entsprechende Schnittstellen
ermöglicht. Hiernach wurde das Frontend entsprechend nach dem konzipierten
Prototypen (s. \autoref{sec:interface-design}) realisiert. Abschließend wurde
das Dashboard implementiert.

\section{Implementierung des Backends}

In diesem Abschnitt werden die Struktur des Backends und die Implementierung
seiner Funktionalitäten näher erläutert. Die zu implementierenden
Funktionalitäten sind aus \autoref{sec:concept-func} zu entnehmen. Zunächst wird
der Aufbau einer Strapi-Anwendung erläutert und wie diese um die benötigten
Kern-Funktionalitäten erweitert wurde. Anschließend wird die Einbindung von
Push-Benachrichtigungen näher beschrieben. Abschließend wird erklärt, wie die
Feedback-Funktionalität aufbauend auf Push-Benachrichtigungen implementiert
wurde.

\subsection{Struktur eines Strapi-Projekts} \label{ssec:impl-backend-structure}

Im Folgenden wird die Struktur des Backends und seiner verschiedenen
Teilkomponenten erläutert. Die Verzeichnisstruktur wird in
\autoref{fig:impl-backend-structure} aufgezeigt. Zur bessern Lesbarkeit werden
einige Dateien und Unterverzeichnisse ausgeblendet. Das Strapi Projekt teilt
sich vier wesentliche Teilbereiche auf: API, Komponenten, Konfiguration und
Plugins. Diese vier Teilbereiche finden sich in der Verzeichnisstruktur in den
entsprechenden Ordnern wieder.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=.45\linewidth]{impl/dir_tree_backend.png}
    \caption{Verzeichnisstruktur des Backends}
    \label{fig:impl-backend-structure}
\end{figure}

Der \lstinline[style=code, style=inline]{/api} Ordner beinhaltet die
verschiedenen angelegten APIs des Strapi Projekts. Die meisten der APIs nutzen
hierbei Inhaltstypen (Content-Types). Inhaltstypen werden in Strapi genutzt, um
die Struktur und Art eines Inhalts zu definieren. Die Datenstruktur eines
Inhaltstyps wird dabei durch Attribute festgelegt, welche aus Name, Art und
einstellbaren Einschränkungen bestehen. Strapi stellt drei Arten von
Inhaltstypen bereit: Kollektionen, Einzeltypen und Komponenten. Während
Kollektionen eine Vielzahl von Einträgen beinhalten kann, bestehen Einzeltypen
aus nur einem Eintrag. Komponenten sind hingegen ein wiederverwendbarer
Inhaltstyp, welcher nur in Verbindung mit Kollektionen oder Einzeltypen genutzt
werden kann. Sie sind im \lstinline[style=code, style=inline]{/components}
Verzeichnis wiederzufinden. Die APIs des Systems sind in
\autoref{fig:impl-backend-apis} zu sehen.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=.4\linewidth]{impl/dir_apis.png}
    \caption{Verzeichnisstruktur der Inhaltstypen}
    \label{fig:impl-backend-apis}
\end{figure}

Jede API wird wie folgt unterteilt (s. \autoref{fig:impl-backend-content-type}
zur Verzeichnisstruktur) und anschließend näher erläutert:

\begin{enumerate}
    \setlength{\itemsep}{1em}
    \item \textbf{Konfiguration (/config)} \\
          Zuweisung von Routen zu Kontroller-Funktionen unter Angabe von
          \textit{HTTP-Methode, URL} und \textit{Kontroller-Funktion}.
    \item \textbf{Kontroller (/controllers)} \\
          Enthält Funktionen, welche Anfragen, wie in der Konfiguration
          festgelegt, empfangen, verarbeiten und eine Antwort oder einen Fehler
          zurücksenden.
    \item \textbf{Modelle (/models)} \\
          Legt Datenstruktur und Name des Inhaltstypen fest. Die verfügbaren
          Datentypen werden in \autoref{fig:impl-backend-types} aufgelistet.
          Falls die API keinen Inhaltstypen nutzt, wird dieses Verzeichnis nicht
          benötigt.
    \item \textbf{Dienste (/services)} \\
          Beinhaltet Funktionen, welche zur Wiederverwendung in verschiedenen
          Kontroller-Funktionen gedacht sind. Wird genutzt, um die duplizierten
          Programm-Code zu vermeiden.
\end{enumerate}

\begin{figure}[htpb]
    \centering
    \includegraphics[width=.5\linewidth]{impl/dir_content_type.png}
    \caption{Aufbau eines Inhaltstypen am Beispiel des \textit{Achievement}-Inhaltstypen}
    \label{fig:impl-backend-content-type}
\end{figure}

In der Konfigurationen werden die verschiedenen API Routen des Inhaltstypen
festgelegt. Für jede Route wird die HTTP-Methode, der entsprechende Pfad (z. B.
\textit{/achievements/:id}) und eine Kontroller-Funktion zugewiesen. Bei der
Wahl der HTTP-Methode ist die Funktion der Route zu beachten und sollte der von
\textcite{RFC7231} beschriebenen Semantik folgen. Beispielweise sollte eine
Anfrage, welche lediglich Daten zurückerhalten möchte, die \textit{GET}-Methode
nutzen. Eine Anfrage, welche mir übermittelten Daten einen neuen Eintrag im
System erschafft sollte hingegen die \textit{POST}-Methode nutzen. Alle
voreingestellten Routen sind in \autoref{table:impl-backend-routes} aufgelistet.
Die eingehenden Anfragen werden von der angegebenen Kontroller-Funktion
verarbeitet. \\
Der Kontroller besteht aus Funktionen, welche, wie zuvor beschrieben, ausgeführt
werden, wenn eine für sie hinterlegte Anfrage erhalten wird. In der Anfrage
enthaltene Daten (z. B. abgeschlossenes Abzeichen) werden an die Funktion
übergeben. Innerhalb der Kontroller-Funktion wird die Anfrage verarbeitet und
eine Antwort zurückgesendet. Die Antwort können dabei ein beliebiger
HTTP-Statuscode, binäre Daten oder Daten in JSON-Form sein.
\\
Das Modell bestimmt die Datenstruktur eines Inhaltstypen und nutzt dabei von
Strapi vorgegebene Datentypen (s. \autoref{fig:impl-backend-types}). Jeder
Inhaltstyp setzt sich aus ein oder mehreren Attributen zusammen, welche aus
einem Namen und einem der Datentypen zusammensetzen. Die Attribute können direkt
in der entsprechenden Datei angelegt oder in der Oberfläche von Strapi
festgelegt werden (s. \autoref{fig:impl-backend-content-type-builder}).
\\
Dienste werden genutzt, um duplizierten Code zu vermeiden. Logik, welche an
mehreren Stellen der benötigt wird, kann in einen Dienst geschrieben werden, um
von dort aus in der API benutzt zu werden. Somit fällt der duplizierte Code weg,
was den Code übersichtlicher und leichter anpassbar macht.

\begin{table}[htpb]
    \def\arraystretch{1.25}
    \centering
    \caption{Voreingestellte Routen von Strapi Kollektionen am Beispiel der Abzeichen}
    \label{table:impl-backend-routes}
    \begin{tabular}{lll}
        \uzlhline%
        \uzlemph{Methode} & \uzlemph{Route}              & \uzlemph{Funktion}              \\
        \uzlhline%
        GET               & \textit{/achievements}       & Erhalte alle Abzeichen-Einträge \\
        GET               & \textit{/achievements/:id}   &
        Erhalte Abzeichen-Eintrag mit der angegebenen ID                                   \\
        GET               & \textit{/achievements/count} &
        Erhalte Anzahl der Abzeichen-Einträge                                              \\
        POST              & \textit{/achievements}       &
        Erstellen eines Abzeichen-Eintrags                                                 \\
        DELETE            & \textit{/achievements/:id}   &
        Löschen des Abzeichen-Eintrags mit der angegebenen ID                              \\
        PUT               & \textit{/achievements/:id}   & Verändern des
        Abzeichen-Eintrags mit der angegebenen ID                                          \\
        \uzlhline
    \end{tabular}
\end{table}

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\linewidth]{impl/types.png}
    \caption{Auflistung der verfügbaren Datentypen für Attribute von Inhaltstypen innerhalb Strapis}
    \label{fig:impl-backend-types}
\end{figure}

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\linewidth]{impl/content-types-builder.png}
    \caption{Oberfläche zum Festlegen der Datenstruktur}
    \label{fig:impl-backend-content-type-builder}
\end{figure}

Das \lstinline[style=code, style=inline]{/config/functions} Verzeichnis des
Projekts enthält Code, welcher zum Start des Systems ausgeführt wird. Die von
der \lstinline[style=code, style=inline]{bootstrap.js} exportierte Funktion
wurde hierbei genutzt, um einen Web-Socket Server zu starten und benötigte
Berechtigungen zu setzen. Auf diese Punkte wird in
\ssecref{ssec:impl-backend-push} genauer eingegangen.

Das \lstinline[style=code, style=inline]{/plugins} Verzeichnis kann genutzt
werden, um Strapi um eigene Module zu erweitern. Möglich ist unter anderem das
Hinzufügen von eigenen Seiten innerhalb der Oberfläche oder die Einbindung einer
eigenen Oberfläche zur Bearbeitung von Attributen. In diesem Projekt sind drei
Plugins zu finden: \textit{groups, dashboard} und \textit{location-picker}. Das
Gruppen-Plugin erfüllt eine Funktion im Backend und wird in
\ssecref{ssec:impl-backend-func} näher erläutert. Das Dash\-board und
Location-Picker-Plugin hingegen werden in \autoref{sec:impl-dashboard}
beschrieben.

Abschließend befinden sich im \lstinline[style=code, style=inline]{/tests}
Verzeichnis Softwaretests, welche genutzt werden, um die korrekte Funktionsweise
der Funktionalitäten, wie in \autoref{sec:concept-func} spezifiziert,
sicherzustellen. Diese sind im Veranstaltungskontext besonders wichtig, da
Fehler während der Veranstaltung im schlimmsten Fall eine komplette
Unterbrechung bedeuten könnten (\anfref{Q30}).

\subsection{Implementierung der Kern-Funktionalitäten} \label{ssec:impl-backend-func}

Nachfolgend wird die Implementierung der Kern-Funktionalitäten des Backends
erläutert, welche aus den Anforderungen aus \autoref{sec:analysis-anf} entnommen
werden. Konkret werden im Folgenden die Implementierung der Stationsbesuche,
Abzeichen und Gruppen erläutert.

Das Besuchen von Stationen erfolgt mithilfe der Übermittlung des Stations-Codes,
welcher aus vier Zeichen, begrenzt auf Zahlen und großen Buchstaben, besteht.
Der Stations-Code ist unabhängig von der ID der Station und kann manuell
festgelegt werden. Dieses Vorgehen ist nötig, da die inkrementellen IDs der
Stations-Kollektion zu einfach zu erraten wären. Zudem können Stations-Codes so
im Nachhinein angepasst werden, sollte z. B. ein Fehler im Druck von QR-Codes
passieren. Eine wichtige Einschränkung bei Stationsbesuchen ist das Verbot von
mehrmaligem Besuchen. Um diese Einschränkung sicherzustellen wurde das Besuchen
von Stationen in einer eigenen \textit{Visit} API realisiert. Die Interaktion
mit der Visit API wird in \autoref{fig:impl-backend-visit-seq} vereinfacht dargestellt.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\linewidth]{impl/sequence_visit.png}
    \caption{Interaktion eines Teilnehmenden mit der Visit API}
    \label{fig:impl-backend-visit-seq}
\end{figure}

Um eine Station zu besuchen, wird eine POST Anfrage an \textit{/visit/:code}
abgeschickt, wobei \textit{:code} den Code der Station darstellt. Sollten
Teilnehmende die angegebene Station bereits besucht haben, wird ein
entsprechender Fehlercode zurückgegeben. Andernfalls werden die Daten des
Besuchs, inklusive der Stations-ID, zurückgegeben, um in der Web-App die
Weiterleitung zur entsprechenden Stationsseite zu ermöglichen. Die Datenstruktur
der Stationsbesuche ist in \autoref{fig:impl-backend-visit-data} zu sehen.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\linewidth]{impl/uml_poi.png}
    \caption{Datenstruktur der Station in Verbindung mit Nutzenden. Intern werden Stationen als \textit{poi} (Point of Interest)
        bezeichnet.}
    \label{fig:impl-backend-visit-data}
\end{figure}

Die Stationsbesuche werden dabei bewusst in einer separaten Tabelle gespeichert,
um die Daten später einfacher zu filtern und das Speichern des Besuch-Zeitpunkts
zu ermöglichen.

Das Abschließen von Abzeichen besitzt, für Bild- und Textabzeichen, einige
Parallelen zum Besuchen von Stationen. Auch hier gilt die Einschränkung, dass
ein bereits eingereichtes Abzeichen nicht erneut eingereicht werden können soll,
solange die Einreichung nicht abgelehnt wurde. Hierfür wurde ebenfalls eine
weitere API hinzugefügt: die \textit{Complete} API. Die Interaktion von
Teilnehmenden mit der Complete API ist in
\autoref{fig:impl-backend-complete-seq} grafisch aufbereitet.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{impl/sequence_completion.png}
    \caption{Interaktion eines Teilnehmenden mit der Complete API}
    \label{fig:impl-backend-complete-seq}
\end{figure}

Um ein Text- oder Bildabzeichen abzuschließen, wird eine POST Anfrage an
\textit{/attempt-completion/:id} abgeschickt, wobei \textit{:id} die ID des
Abzeichens darstellt. Bei vorhandener ausstehender Abgabe wird ein Fehlercode
zurückgegeben. Andernfalls wird die übertragene Einreichung in der Datenbank des
Backends gespeichert. Im Gegensatz zur Visit API wird die Complete API auch von
Veranstaltenden genutzt, um Einreichungen zu bewerten. Über das in
\autoref{sec:impl-dashboard} beschriebene Dashboard können Veranstaltende die
Einreichung akzeptieren oder ablehnen. Daraufhin wird eine Anfrage an
\textit{/complete/:id} bzw. \textit{/dismiss/:id} gesendet, wobei die ID des
Abschlussversuchs übergeben wird (vgl.
\autoref{fig:impl-backend-complete-seq-v}). Wird der Abschlussversuch gefunden
wird der entsprechende Status darin gesetzt. Mögliche Statusangaben sind
„pending“, „denied“ und „accepted“. Der „pending“ Status wird dabei
ausschließlich beim Erstellen des Versuchs verwendet. Diese Logik wird jedoch
nur für Text- oder Bildabzeichen genutzt. Für alle anderen Abzeichen wird die
entsprechende Bedingung im Code überprüft und bei erfüllter Bedingung direkt
ein Eintrag mit „accepted“ für das jeweilige Abzeichen erstellt.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\linewidth]{impl/sequence_completion_v.png}
    \caption{Interaktion eines Veranstaltenden mit der Complete API zum Bewerten einer Einreichung}
    \label{fig:impl-backend-complete-seq-v}
\end{figure}

Ähnlich zur Datenstruktur des Stationsbesuchs werden auch Abzeichen und ihre
dazugehörigen Abschlüsse auf zwei Tabellen aufgeteilt (s. \autoref{fig:impl-backend-completion-data}). Der Grund hierfür ist
ebenfalls die Erfassung der Erstellungs- und Bewertungszeit, sowie die einfache
Durchsuchung.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\linewidth]{impl/uml_achievement.png}
    \caption{Datenstruktur der Abzeichen in Verbindung mit Nutzenden}
    \label{fig:impl-backend-completion-data}
\end{figure}

\newpage

Die Gruppen-Funktionalität erweitert Stationsbesuche und Abzeichen, indem
Besuche und Abschlüsse nicht mit Teilnehmenden, sondern analog mit deren Gruppe
verknüpft werden. Sobald ein Gruppenmitglied eine Station oder ein Abzeichen
abschließt, gilt dies somit für alle Mitglieder einer Gruppe. Da die
Gruppen-Funktionalität von Veranstaltenden optional oder ausgeschaltet werden
kann, muss es für Teilnehmende trotzdem möglich sein, diese Aktionen einzeln
auszuführen. Somit ergibt sich die in \autoref{fig:impl-backend-groups-data}
gezeigte Datenstruktur.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\linewidth]{impl/uml_poi_achievement_group.png}
    \caption{Datenstruktur der Abzeichen und Stationen im Zusammenhang mit Gruppen}
    \label{fig:impl-backend-groups-data}
\end{figure}

Bevor Teilnehmende gemeinsam in einer Gruppe agieren können, müssen sie diese
erstellen oder ihr beitreten. Dies geschieht über eine POST Anfrage an die
\textit{/groups/create} oder \textit{/groups/join} Route. Der
\textit{/groups/create} Route muss zusätzlich der Name der zu erstellenden
Gruppe übermittelt werden, während die \textit{/groups/join} Route den
Gruppen-Code der beitretenden Gruppe benötigt. Abschließend kann die Gruppe auch
wieder verlassen werden, indem eine POST Anfrage an die \textit{/groups/leave}
Route geschickt wird.
\\
Sobald Teilnehmende Mitglied einer Gruppe sind, wird bei Stationsbesuchen und
Abzeichen Einreichungen oder Abschlüssen die Gruppe, statt der Teilnehmenden,
hinterlegt. Gleichzeitig wird beim Auslesen der Besuche und Abschlüsse nicht
mehr nach der Nutzer-ID, sondern der Gruppen-ID gefiltert. Alle
Gruppenmitglieder erhalten somit die neu erstelle Aktion. Eine Einschränkung
dieses Systems ist der temporäre Verlust von Daten bei Beitreten oder Verlassen
einer Gruppe, da jeweils nur Gruppen- bzw. Einzeldaten berücksichtigt werden.
Sobald Teilnehmende ihre Gruppe verlassen, werden wieder Einzeleinträge
angezeigt, da die Gruppeneinträge nicht mehr mit den Teilnehmenden
assoziiert sind. Dies gilt analog auch für das Beitreten einer Gruppe.

\subsection{Implementierung der Push-Benachrichtigungen} \label{ssec:impl-backend-push}
\label{ssec:impl-backend-push}

Gemäß \textit{Ft-V-5} (s. \ssecref{ssec:func-new}) sollen Teilnehmende von
Veranstaltenden jederzeit benachrichtigt werden können. Im Web-Kontext kann dies
über die Web-Push API erfolgen, welche es ermöglicht, auch außerhalb der Nutzung
der Web-App Benachrichtigungen zu erhalten. Jedoch wird die Web-Push API nicht
von Safari auf iOS unterstützt \cite{MDN2021}, weshalb eine Rückfalllösung
gebraucht wird. Unter Beachtung dieser Beschränkungen wurde ein drei-stufiges
Verfahren entwickelt, welches sich aus der Push API und einem Web-Socket Server
zusammensetzt. Im Folgenden werden diese beiden Technologien näher vorgestellt
und ihre Aufgabe und Interaktion im System präsentiert.

Der Web-Push Standard ermöglicht das Versenden und Empfangen von
Push-Benach\-richti\-gungen im Web-Kontext. Ein Endgerät, wie z. B. ein Smartphone
mit Browser, kann durch die Push API einen Push-Dienst abonnieren. Durch das
Abonnieren erhält das Endgerät eine eindeutige URL, welche von einem Server, wie
z. B. dem Backend, genutzt werden kann, um jederzeit Nachrichten an das Endgerät
zu senden. Ein besonderer Vorteil der Web-Push Standards ist das Versenden von
Nachrichten außerhalb der Browsernutzung. Sollten Teilnehmende die Web-App zum
Zeitpunkt des Versendens nicht ausführen, so wird die Nachricht trotzdem
empfangen. Die Funktionsweise der URL birgt jedoch ein Sicherheitsrisiko, da
jeder mit dieser URL beliebige Nachrichten an das entsprechende Endgerät senden
kann. Um diese Sicherheitslücke zu schließen, muss jedes Abonnement
verschlüsselt werden. Dies geschieht mit VAPID-Schlüsseln \cite{VAPID}, wodurch
auf dem Endgerät sichergestellt werden kann, das die Nachricht vom richtigen
Server stammt.

Web-Sockets hingegen sind für die Echtzeit-Kommunikation zwischen Endgerät und
Server gedacht. Sie ermöglichen das Senden und Empfangen von Nachrichten in
beide Richtungen. Somit kann das Endgerät, im Gegensatz zum Web-Push Standard,
auch Nachrichten an den Server schicken. Hierzu wird eine dauerhafte Verbindung
mit dem Server aufgebaut, welche jedoch mit dem Schließen der Web-App abbricht.
Im Vergleich zum Web-Push Standard eigenen sich Nachrichten über Web-Sockets
somit nur während der Nutzung der App. Jedoch werden für Web-Sockets keine
weiteren Verschlüsselungsmethoden, neben der Nutzung von HTTPS, benötigt. Zudem
vereinfachen JavaScript-Bibliotheken wie Socket.IO\footnote{\url{https://socket.io/}},
welche in dieser Arbeit verwendet wurde, die Nutzung von Web-Sockets und
verwenden intern weitere Methoden um eine stabile Verbindung über eine
breite Auswahl an Geräten zu garantieren \cite{SocketIO2022}.


Basierend auf den Fähigkeiten der beiden vorgestellten Technologien wird ein
drei-stufiges Verfahren zur Benachrichtigung entwickelt, welches in
\autoref{fig:impl-backend-push} präsentiert wird. Wenn Veranstaltende eine
Nachricht versenden, wird zunächst das Versenden mit Web-Push versucht. Sollte
dies fehlschlagen, wird die Nachricht stattdessen über eine Web-Socket
Verbindung versendet. Falls auch dies fehlschlägt, wird die Nachricht im
Nutzerprofil gespeichert. Sobald Teilnehmende sich wieder mit dem Server
verbinden, wird dieser Vorgang erneut versucht. Allerdings wird die Nachricht in
diesem Fall verworfen, sollte die Nachricht weder per Web-Push noch Web-Sockets
versendet werden können (s. \autoref{fig:impl-backend-push-connect}).

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\linewidth]{impl/flow_push.png}
    \caption{Verfahren zum Versenden von Benachrichtigungen an Teilnehmende}
    \label{fig:impl-backend-push}
\end{figure}

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\linewidth]{impl/flow_push_connect.png}
    \caption{Verfahren bei ausstehenden Benachrichtigungen}
    \label{fig:impl-backend-push-connect}
\end{figure}

\subsection{Implementierung der Feedback-Funktionalität}

Die Feedback-Funktionalität baut auf der Implementierung der
Push-Benachrichtigungen auf. Sobald Veranstaltende eine neue Feedback-Anfrage
verschicken, wird diese an alle Teilnehmende über das in
\ssecref{ssec:impl-backend-push} beschriebene Verfahren gesendet. Dabei wird
jede Feedback-Anfrage mit einer eindeutigen ID versehen, um die Antworten später
noch zur jeweiligen Anfrage zuordnen zu können. Die Datenstruktur des
Feedback-Systems wird in \autoref{fig:impl-backend-feedback-data} dargestellt.
Jede verschickte Feedback-Anfrage ist hierbei ein Eintrag in der
\textit{feedback} Tabelle, während die Antworten der Teilnehmenden als Einträge
in der \textit{feedback-response} Tabelle gespeichert werden. Hierzu wird die
Antwort als POST Anfrage an \textit{/feedback/respond} gesendet.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.6\linewidth]{impl/uml_feedback.png}
    \caption{Datenstruktur des Feedback-Systems}
    \label{fig:impl-backend-feedback-data}
\end{figure}

%\subsection{Softwarequalität}

% - Aussagekräftige Fehlermeldungen ->
% - Softwaretests

\section{Implementierung des Frontends}

Dieser Abschnitt präsentiert bedeutendsten technischen Aspekte des Frontends.
Zunächst wird der Aufbau des Projekts und die Nutzung des Vue CLI betrachtet.
Daraufhin wird die Komponentenstruktur am Beispiel der interaktiven Karte näher
erläutert. Abschließend werden das native App-Erlebnis und die
Fortschrittsspeicherung aufgegriffen.

\subsection{Struktur mit Vue CLI} \label{ssec:impl-frontend-structure}

Zur Erstellung und Verwaltung des Projekts wurde das \textit{Vue CLI} genutzt.
Vue CLI ist ein Kommandozeilenprogramm, welches die Einrichtung und Verwaltung
von komplexeren Vue Projekten stark vereinfacht. Das Erstellen eines Projekts
erfolgt nach Installation des Vue CLI durch den Befehl \lstinline[style=code,
    language=bash, style=inline]{vue create <projekt-name>}. Während der Erstellung
des Projekts können zusätzliche Plugins ausgewählt werden, welche einige
Vue-spezifische oder allgemeine Funktionalitäten hinzufügen. Für dieses Projekt
wurden die Plugins aus \autoref{table:impl-frontend-vuecli-plugins} zur
Installation ausgewählt. Die Struktur des Vue-Projekts dieser Arbeit wird in
\autoref{fig:impl-frontend-vuecli-dir} präsentiert. Die fettgedruckten
Verzeichnisse sind nicht durch das Vue CLI generiert worden, sondern wurden
manuell erstellt. Nachfolgend wird die Struktur näher erläutert.

\begin{table}[htpb]
    \caption{Gewählte Vue CLI Plugins und ihre Funktion}
    \label{table:impl-frontend-vuecli-plugins}
    \begin{threeparttable}[t]
        \def\arraystretch{1.25}
        \centering
        \begin{tabularx}{\textwidth}{lX}
            \uzlhline%
            \uzlemph{Plugin}     & \uzlemph{Funktion}                                                      \\
            \uzlhline%
            \textbf{TypeScript}\tnote{1}  & Ermöglicht die Nutzung von TypeScript innerhalb
            eines Vue Projekts. TypeScript ergänzt JavaScript um eine Syntax für
            Datentypen, welche besser Vorschläge in Entwicklungsumgebungen
            ermöglicht und vorzeitig Fehler aufzeigen kann.                                                \\
            \textbf{PWA Support} &
            Generiert alle nötigen Dateien und Konfigurationen, welche für die
            Nutzung einer PWA benötigt werden. Zudem wird die Anpassung von PWAs an
            die eigenen Bedürfnisse vereinfacht.                                                           \\
            \textbf{Router}      &
            Fügt \textit{vue-router}\tnote{2}und seine benötigten Dateien zum Projekt hinzu.
            Vue-router ermöglicht das Anlegen von und Navigieren zu mehreren (Unter-)Seiten
            innerhalb der Web-App.                                                                         \\
            \textbf{Vuex}\tnote{3}        & Ergänzt das Projekt um einen zentralisierten
            Speicher, welcher das einfache Verwalten von globalen Zuständen
            ermöglicht. Dies umfasst Daten wie z. B. den Standort des Nutzers,
            welcher in mehreren Teilen der App benötigt wird.                                              \\
            \uzlhline
        \end{tabularx}
        \vspace{-0.75cm}
        \begin{tablenotes}
            \item [1] \url{https://www.typescriptlang.org/}
            \item [2] \url{https://router.vuejs.org/}
            \item [3] \url{https://vuex.vuejs.org/}
        \end{tablenotes}
    \end{threeparttable}
\end{table}


\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.45\linewidth]{impl/dir_frontend.png}
    \caption{Verzeichnisstruktur des Frontends mit Vue CLI}
    \label{fig:impl-frontend-vuecli-dir}
\end{figure}

Projekte, welche mit dem Vue CLI erstellt werden, gliedern sich im wesentlichen
in zwei Ordner: \textit{public} und \textit{src}. Der \textit{public} Ordner
beinhaltet statische Datein, wie z. B. die \textit{index.html}, welche als
Template für die Vue-App genutzt wird. Weitere Dateien, die im \textit{public}
Ordner gefunden werden können, sind \textit{robots.txt}, welche
Suchmaschinen Hinweise zur Indexierung der Seite geben, und
\textit{favicon.ico}, welches vom Browser als Tab-Icon verwendet wird.

Der \textit{src} Ordner beinhaltet Code der eigentlichen Vue-App und ist in
weitere Ordner eingeteilt. Diese Ordner unterteilen den Code der App in seine
Aufgaben, wie z. B. das Anzeigen von Inhalten oder Abfragen von externen Daten.
Der Einstiegspunkt der App bilden hierbei die \textit{main.ts} und
\textit{App.vue}. In ihnen wird die Vue-App initialisiert und das Grundlegende
Layout festgelegt. Plugins und globale Stylesheets werden hierbei in der
\textit{main.ts} eingebunden. Die \textit{App.vue} stellt hingegen die oberste
Vue-Kompontente dar, in welcher die gesamte Web-App dargestellt wird. Dauerhaft
sichtbare Element, wie die Navigationsleiste, wurden hier angelegt, um
duplizierten Code zu vermeiden.

Alle Ansichten befinden sich im \textit{views} Ordner. Die Ansichten selber
nutzen meist mehrere Komponenten aus dem \textit{components} Ordner. Dies
ermöglicht das Wiederverwenden von Komponenten in mehreren Ansichten, wodurch
duplizierter Code vermieden werden kann. Zudem ermöglichen Komponenten das
Abkapseln bestimmter Logik, um die Vue-App klarer zu strukturieren. Bilder und
andere Dateien, welche fest in der App eingebunden werden, sind im
\textit{assets} Ordner zu finden.

Die einzelnen Ansichten lassen sich jeweils über ihre URL aufrufen. Hierzu wird
diese, sowie einige weitere Optionen, innerhalb der \textit{vue-router}
Konfiguration im \textit{router} Ordner festgelegt. Zudem beinhaltet der
\textit{store} Ordner den im vorherigen Abschnitt erwähnten, globalen
\textit{Vuex} Speicher. Dieser wird genutzt, um Daten wie die Position der
Teilnehmenden oder Einstellungen abzuspeichern, da diese an vielen Stellen der
Vue-App benötigt oder verändert werden.

Alle bisher erwähnten Verzeichnisse und Dateien werden automatisch durch das Vue
CLI generiert. Zur bessern Übersichtlichkeit wurden weitere Ordner angelegt, um
eigene Funktionen nach Aufgabe zu gruppieren. Die \textit{models} und
\textit{services} Ordner beinhalten Funktionen zur Abfrage von Daten aus dem
Backend. Hierbei werden in \textit{models} die Typen der verschiedenen
Datenstrukturen des Backends repliziert. Die Anfrage-Funktionen des
\textit{services} Verzeichnisses nutzen diese Typen, um in der Vue-App die
Typisierung von externen Anfragen zu erlauben. Somit können Fehler in der
Nutzung der abgefragten Daten schneller erkannt werden. Der \textit{helpers}
Ordner enthält einige allgemeinere, hilfreiche Funktionen, welche in vielen
Teilen der Vue-App genutzt werden. Im \textit{middleware} Ordner sind sogenannte
„Middlewares“ zu finden. In diesem Kontext handelt es sich hierbei um
Funktionen, welche bei der Navigation zwischen Ansichten aufgerufen werden, um
z. B. zu kontrollieren, ob Teilnehmende authentifiziert sind. Das \textit{types}
Verzeichnis enthält TypeScript Typen für Pakete, welche keine Typen besitzen.
Somit können auch für diese Pakete die Vorteile von TypeScript genutzt werden.


\urldef\vuemixin\url{https://vuejs.org/guide/reusability/composables.html#comparisons-with-other-techniques}

Abschließend verfügt Vue.js seit der Version 3.0 über zwei verschiedene Arten,
den Aufbau von Komponenten organisieren: die Composition API und die Options
API. Die Options API ist hierbei die traditionelle Art Vue Komponenten zu
organisieren und war vor Version 3.0 die einzige Möglichkeit.
\autoref{fig:impl-frontend-vue-api-options} zeigt eine Beispiel-Komponente,
welche die Options API nutzt. Hierbei wird die Komponente nach der Art ihrer
Inhalte, der sogenannten „Options“, strukturiert. Alle Methoden, Variablen und
übergebenen Werte werden jeweils gruppiert angegeben. Diese Art der
Strukturierung ermöglicht einen einheitlichen Aufbau über große Projekte. Jedoch
besitzt sie auch einige große Nachteile, wenn Teile der Komponente extrahiert
und wiederverwendbar gestaltet werden sollen\footnote{\vuemixin}.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.65\linewidth]{impl/code_options.png}
    \caption{Beispiel-Komponente mit der Options API (Nur Script)}
    \label{fig:impl-frontend-vue-api-options}
\end{figure}

\urldef\vuecomp\url{https://vuejs.org/guide/extras/composition-api-faq.html#why-composition-api}
\urldef\vuets\url{https://vuejs.org/guide/extras/composition-api-faq.html#better-type-inference}

Die Composition API wurde konzipiert um dieses Problem und weitere zu beheben.
Anstatt Optionen anzugeben, werden die gewünschten Funktionalitäten importiert
und in beliebiger Struktur genutzt. Somit kann der Code nach seiner Funktion
gruppiert werden. Zum Vergleich ist die Composition API Version der
Beispiel-Komponente auf \autoref{fig:impl-frontend-vue-api-composition} zu
sehen. Zusätzlich wird TypeScript in der Composition API besser
unterstützt\footnote{\vuets}. In dieser Arbeit wird, aufgrund der vorgestellten
Vorteile und Empfehlung der offiziellen Dokumentation\footnote{\vuecomp}, die
Composition API genutzt.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.65\linewidth]{impl/code_composition.png}
    \caption{Beispiel-Komponente mit der Composition API (Nur Script)}
    \label{fig:impl-frontend-vue-api-composition}
\end{figure}

%\subsection{API-Kommunikation}

\subsection{Komponentenstruktur}

Wie in \ssecref{ssec:impl-frontend-structure} beschrieben, besteht die Vue-App
aus einer Hierarchie an Ansichten und Komponenten. Im Folgenden wird am Beispiel
der interaktiven Karte aufgezeigt, wie diese Strukturen entwickelt wurden.
Hierfür wurde die Hierarchie der interaktiven Karte vereinfacht grafisch
dargestellt (s. \autoref{fig:impl-frontend-components-structure}).

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\linewidth]{impl/component_map.png}
    \caption{Vereinfachter hierarchischer Aufbau der interaktiven Karte}
    \label{fig:impl-frontend-components-structure}
\end{figure}

Den Startpunkt der Hierarchie bildet, wie bereits in
\ssecref{ssec:impl-frontend-structure} beschrieben, die \textit{App.vue}. Im
Beispiel ist zurzeit die Karten-Ansicht ausgewählt, welche sich im
\textit{views} Verzeichnis befindet (s. \autoref{fig:impl-frontend-dirs} links,
\textit{Map.vue}). Diese wird durch ihren zugehörigen Pfad \textit{/map}
erreicht, welcher so im vue-router definiert wurde. Da die Aufgabe der Karte das
Anzeigen aller Stationen ist, fragt die Karten-Ansicht eine Liste aller
Stationen vom Backend an. Zusätzlich wird der Standort aus dem Vuex Speicher
benötigt, welcher zur Berechnung der Distanz und dem Anzeigen auf der Karte
genutzt wird. Intern überwacht die Karten-Ansicht zudem, welche Station aktuell
ausgewählt ist.

\begin{figure}[htpb]
    \centering
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=.7\linewidth]{impl/dir_frontend_views.png}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[width=.7\linewidth]{impl/dir_frontend_components.png}
    \end{minipage}
    \caption{Ausschnitt der Inhalte der \textit{views} und \textit{components}
    Verzeichnisse. Die Strukturierung und Benennung der Inhalte folgt dem Vue
    Style Guide \cite{You2022b}}
    \label{fig:impl-frontend-dirs}
\end{figure}

Diese Daten werden nach Bedarf an die Komponenten der Ansicht weitergegeben. Die
Karten-Ansicht besteht hierbei im Wesentlichen aus zwei Komponenten: der
interaktiven Karte (\textit{mapbox/Map/Map.vue}) und einem Pop-up
(\textit{TheMapPopup.vue}), welche sich im \textit{components} Verzeichnis
befinden (s. \autoref{fig:impl-frontend-dirs} rechts). Wie
\autoref{fig:impl-frontend-components-structure} zu entnehmen ist, erhält die
\textit{Map}-Komponente alle drei Daten der Karte-Ansicht, während das Pop-up
lediglich die ausgewählte Station und den Standort übergeben bekommt. Die
interaktive Karte ist hierbei nur für das Anzeigen der Karte, nicht aber der
Stationsicons, verantwortlich.

Um die Stationen anzuzeigen wird intern die Map-Marker Komponente genutzt. Für
jede in der Liste vorhandene Station wird eine Map-Marker Komponente
instanziiert und mit den Daten der jeweiligen Station versorgt. Hieraus werden
Icon und Position der Station entnommen, um diese korrekt anzuzeigen. Zudem
übernimmt die Map-Marker Komponente die Anpassung des Icons, falls die Station
ausgewählt ist oder bereits besucht wurde. Der Standort wiederum benötigt diese
Logik nicht und wird separat verwendet.

Die Pop-up Komponente nutzt die übergebene, ausgewählte Station um ihre
Informationen wie Titel und Beschreibung anzuzeigen. Zusätzlich wird der
Standort verwendet, um die Distanz zur ausgewählten Station zu berechnen und
anzuzeigen. Intern setzen sich diese Komponenten noch aus weiteren Komponenten
zusammen, wie z. B. einer Icon-Komponente. Zur Übersichtlichkeit und
Verständlichkeit wurde dieses Beispiel jedoch vereinfacht.

Dieser hierarchische Aufbau und die Weitergabe der Daten an untergeordnete
Komponenten findet sich in der gesamten Vue-App wieder. Hierdurch können
Komponenten im System an vielen Stellen wiederverwendet werden, was
Entwicklungszeit spart und unterschiedliche Fehler in sich widerholendem Code
vermeidet.

\subsection{Natives App-Erlebnis}
% Enkodierung des UI-Zustandes in der URL

Aufgrund der technischen Limitierungen ist eine native App im Rahmen dieser
Bachelorarbeit nicht möglich (s. \ssecref{ssec:analysis-old-tech}). Um
Teilnehmenden trotzdem ein möglichst natives App-Erlebnis zu ermöglichen, wurden
einige Maßnahmen eingesetzt. Nachfolgend wird erläutert wie der
\textit{vue-router} und die \textit{PWA}-Funktionalität hierfür genutzt wurden.

Traditionelle Webseiten müssen für jede aufgerufene Seite eine neue Anfrage an
den jeweiligen Server stellen. Dies ist mit meist mit einer längeren Wartezeit
verbunden. Jedoch werden Interaktionen bei Wartezeiten von mehr als einer
Sekunde bereits die Gedankengänge von Nutzenden unterbrochen und die Interaktion
fühlt sich wahrnehmbar verzögert an \cite{Nielsen1994b}. Um dieses Problem zu
umgehen, verwendet diese Arbeit das \textit{vue-router} Paket. Im Gegensatz zu
traditioneller Navigation zwischen Seiten wird bei der Verwendung von vue-router
der Großteil der Navigation mithilfe von JavaScript übernommen.

Anstatt bei jedem Aufruf erneut die HTML-Seite zu laden, wird nur noch eine
HTML-Seite angefragt, welche alle benötigten Daten der restlichen Anwendung
enthält. Bei jedem Seitenwechsel wird der Inhalt der Seite mithilfe des
JavaScript-Codes ausgetauscht. Dies verkürzt die Ladezeit und erlaubt es, die
Übergänge zwischen den Seiten nach Bedarf anzupassen. Das Prinzip dieser
gebündelten Seite nennt sich \textit{Singe-Page-Application (SPA)}.

Ein Nachteil von SPAs ist die Größe der Dateien beim ersten Aufruf. Um dieses
Problem zu minimieren, werden die Dateien meist stark komprimiert. Zudem lassen
sich verschiedene Teile der SPA nach Bedarf aufteilen und nachladen. Auch wenn
hier wieder eine Anfrage an den Server gestellt werden muss, ist dies schneller
als das Laden einer kompletten Seite. Zudem kann hier die PWA-Funktionalität
genutzt werden.

Progressive Web-Apps ermöglichen u. a. das Vorladen und Speichern von Webseiten,
um diese auch offline nutzen zu können. Hierzu werden JavaScript \textit{Service
Worker} genutzt. Service Worker sind JavaScript Prozesse, welche auf einem
separaten Thread ausgeführt werden und auch nach dem Schließen der Seite noch
aktiv sind. In ihnen können Dateien festgelegt werden, welche beim ersten Aufruf
der Seite direkt geladen und gespeichert werden sollen. Obwohl dies eine längere
Ladezeit zum ersten Aufruf bedeutet, werden alle weiteren Navigationen
zusätzlich beschleunigt, während die übertragenen Daten minimiert werden.
Besonders die Minimierung der übertragenen Daten spielt eine wichtige Rolle im
mobilen Kontext durch meist begrenzte Datenvolumen in Mobilfunkverträgen.

Zudem werden Service Worker benötigt, um Push-Benachrichtigungen zu empfangen.
Die Notifications
API\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API}}
erlaubt es native Benachrichtigungen zu erstellen, welche das native
App-Erlebnis födern.

\subsection{Persistente Nutzerdatenspeicherung}

Da die Nutzung der App sich über mehrere Wochen erstrecken kann (s.
\autoref{sec:analysis-context}), ist die sichere Speicherung der Fortschritte
der Teilnehmenden ein wichtiger Faktor. Um dies zu gewährleisten werden die
Fortschrittsdaten auf dem Server in einem Nutzerprofil gespeichert. Dieses
Profil wird automatisch mit dem Akzeptieren der Datenschutzerklärung erstellt.
Da Teilnehmende keine identifizierenden Daten, wie z. B. eine E-Mail Adresse,
angeben müssen, wird stattdessen eine eindeutige ID generiert. Diese ID basiert
auf dem Browser Fingerprint der Teilnehmenden. Der Browser Fingerprint setzt
sich aus vielen auslesbaren Eigenschaften des Browsers zusammen. Hierzu gehören
z. B. die Bildschirmgröße, installierten Schriftarten, genutzte Hardware oder
Implementierungsunterschiede der verschiedenen
Browser\footnote{\url{https://fingerprintjs.com/blog/browser-fingerprinting-techniques/}}
(s. \autoref{fig:impl-frontend-browser-fingerprinting}). In dieser Arbeit wird
die JavaScript Bibliothek \textit{FinterprintJS} \cite{FingerprintJS2022}
genutzt, um die ID zu generieren.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=.8\linewidth]{impl/browser_fingerprinting.png}
    \caption{Ausschnitt der genutzten Attribute zur Identifizierung des Browsers
    \cite{FingerprintJS2022}}
    \label{fig:impl-frontend-browser-fingerprinting}
\end{figure}

Nachdem die ID generiert wurde, wird sie als Nutzername und Passwort verwendet,
um einen neuen Account zu erstellen. Für alle weiteren Aktionen innerhalb der
Web-App, wie z. B. dem Besuchen von Stationen, wird der Account in der Anfrage
genutzt. Somit können die ausgeführten Aktionen im Nutzerprofil der
Teilnehmenden hinterlegt werden. Der Vorteil des Browser Fingerprinting liegt
hierbei in seiner Eigenschaft langlebig zu sein. Über mehrere Wochen kann
ein Browser Fingerprint für das gleiche Gerät unverändert bleiben. Somit ist die
Wahrscheinlichkeit hoch, dass selbst nach dem Löschen des Browserspeichers die
gleiche ID generiert wird. Folglich wird der gleiche Nutzeraccount verwendet und
ein Datenverlust vermieden.

\section{Implementierung des Dashboards} \label{sec:impl-dashboard}

In diesem Abschnitt wird die Implementierung des Dashboards präsentiert. Da es
sich hierbei um ein Strapi Plugin handelt, wird zunächst der Aufbau eines
Plugins beschrieben. Daraufhin wird die Implementierung der visuellen
Aufbereitung der Daten erläutert. Abschließend wird das Location-Picker Plugin
implementiert, welches die Eingabe von Standortdaten vereinfacht.

\subsection{Aufbau eines Strapi Plugins}

Nachdem in \ssecref{ssec:impl-backend-structure} bereits die grundlegende
Struktur eines Strapi Projekts erklärt wurde, wird in diesem Abschnitt der
Aufbau eines Plugins innerhalb Strapis näher erläutert.
%TODO: Continue

\subsection{Implementierung der Statistiken}

Eine der Hauptfunktionen des Dashboards ist das Überblicken der Veranstaltung
und seiner gesammelten Daten. Um dies zu ermöglichen wurden die Daten der
Teilnehmenden, Stationen und Abzeichen im Dashboard visuell aufbereitet.
Nachfolgend wird erklärt wie das \textit{victory-charts} Paket dazu genutzt
wurde, die Statistiken zu realisieren.
%TODO: Continue

\subsection{Implementierung des Location-Picker Plugins}

Der Standort einer Station ist eine seiner fundamentalen Informationen. Jedoch
besitzt Strapi keine vorhandene Oberfläche oder Datentyp um Standortdaten
einzutragen. Um die mühsame Eintragung von Longitude und Latitude zu vermeiden,
wurde ein Plugin implementiert, welches das Setzen eines Standorts mithilfe
einer interaktiven Karte ermöglicht. Im Folgenden wird die Implementierung
dieser mit erläutert.
%TODO: Continue

\section{Nutzung des Systems}

\subsection{Installation}

\subsection{Ausführung mit Docker}